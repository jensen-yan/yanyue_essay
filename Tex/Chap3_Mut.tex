\chapter{微译器介绍}\label{chap:MUT}

\section{微译器架构细节}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\linewidth]{./image/front_end_transutor.pdf}
  \caption{架构细节图。}
  \label{img:front_end_transutor}
\end{figure}

首先简要回顾一下微译器的架构细节，如图\ref{img:front_end_transutor}：

\subsection{硬件部分}

在硬件部分，引入了\textbf{翻译缓存}（Translation Cache），该缓存作为一级缓存负责存储预翻译的微码指令集，替代了原本的微码缓存。
翻译缓存的每行组织形式和微码缓存类似，都是前面部分存放微码指令（这里为融合微码指令，下一节详细介绍），
后面存放立即数（主要为了方便一条变长的X86指令，能更好的翻译成定长的融合微码指令），
微码指令和立即数相向生长，中间可能有空洞，这也是新产生的性能开销。

此外与传统微码架构不同，微码缓存数据是直接来源于CPU和指令缓存；
而翻译缓存通过二进制翻译透过内存层次（从内存加载到L3 Cache, 再到L2Cache， 最后到微码缓存）进行填充，
取代了传统的指令缓存和译码器的角色。
在传统X86架构下，取指部件会同时查询指令缓存和微码缓存；
而在微译器架构下，取指部件仅查询翻译缓存，硬件的译码器被软件的二进制翻译器取代。

\subsection{软件部分}

在软件部分，引入了静态和动态二进制翻译器。
程序首先通过静态二进制翻译器被翻译成微指令，并被写入预翻译文件，存储在硬盘中。
在客户程序执行阶段，预翻译文件被加载到内存中，程序计数器被设置为客户程序的入口。
取指部件从翻译缓存中取指，若翻译缓存或内存层次命中，则与从指令缓存取指类似，不断取指执行。
若翻译缓存和内存层次均未命中（例如存在自修改代码等），说明客户指令还未翻译，此时会调用动态二进制翻译器进行实时翻译。



\section{融合微码介绍}
本节详细介绍重要的一个概念——融合微码。“融合”代表它能融合了多种指令集的特征，
包括X86和RISCV，未来还可以支持ARM，MIPS等其他指令集，
或许叫统一微码也更好理解。但融合并非简单的把所有指令集简单拼接就好，这会造成指令集冗余，挤占有限的编码空间。

“微码”这个名字主要由于它在翻译缓存中的组织形式和传统的X86微码缓存组织形式类似，并且更像是不同指令集的更低级表现形式；
此外目前第一代的融合微码是在原有的Gem5 X86微码上扩充的，
所以便于理解仍然保留融合微码的名字。

但事实上，融合微码有很大特征很像一个“RISC指令集”。
由于我们的融合微码指令是需要存储在磁盘中的，并不像传统X86微码只是作为一个“暂时指令”存在于CPU运行期间，
所以融合微码指令需要像普通指令集一样进行\textbf{编码}，
编译器（或者二进制翻译器）把指令\textbf{编码}为定长的融合微码指令，并存储于磁盘中。
CPU再从磁盘中加载融合微码指令，\textbf{解码}为CPU识别的信息，这一阶段也叫“译码阶段”。
因此从这个角度来说，加上指令定长、只能操作寄存器、指令间关系被简化等特征，融合微码很像一个普通的“RISC指令集”。
因此融合微码类似传统指令集概念，也是有编码空间的概念。