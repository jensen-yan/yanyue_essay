\chapter{RISC-V微译器优化方案}\label{chap:Opt}

前文中提到了RISC-V微译器的引入能消除间接跳转的开销并缩小指令集语义差异，从而提升二进制翻译器的性能。
然而，RISC-V微译器的引入也会带来一些新的问题，产生新的性能瓶颈，本节将首先分析RISC-V微译器的开销来源，然后
针对这些问题提出一些优化方案，从而减缓这些性能瓶颈，进一步提升性能。




\section{RISC-V微译器开销来源}
RISC-V微译器的主要开销来源于磁盘、内存、缓存三个方面，前两者来源于预翻译文件中\textbf{重复存储}机制，后者来源于翻译缓存的\textbf{存储效率}问题。
重复存储机制是为了减少动态二进制翻译的开销，提高性能，但是会增加磁盘和内存的开销；
存储效率问题是由于翻译缓存行的固定长度，导致存储效率较低，缓存缺失率较高，进而影响性能。
本小节主要分析重复存储机制，下一小节将分析存储效率问题并给出优化方案。

预翻译文件的作用和可执行文件（Linux中为ELF格式文件）类似，是存储程序的二进制指令的文件格式，处理器会从预翻译文件中加载融合微码指令集，进而译码执行。
预翻译文件的数据段和ELF文件数据段相同，但是由于重复存储机制，代码段相对于ELF文件的代码段会膨胀64倍（64为翻译缓存行长度），接下来会举例介绍预翻译文件的代码段格式。

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=1\linewidth]{./image/aot_format.pdf}
  \bicaption{\enspace 预翻译文件格式}{\enspace The format of the Ahead-of-Time file}
  \fignote{A、B、C、D为客户指令，a0、b0、c0、d0为翻译出的融合微码指令，由于重复存储，会存储a0-b0-c0-d0、b0-c0-d0、c0-d0、d0这
  四行融合微码指令，并填充对齐。}
  \label{img:aot_format}
\end{figure}

如图\ref{img:aot_format}，展示了预翻译文件的代码段格式，为了简单起见，假设图中的指令缓存行大小为8字节，包含4条客户指令A、B、C、D，
起始地址分别为0x0、0x2、0x3、0x6，
生成的融合微码指令为a0、b0、c0、d0。
对应的预翻译文件会有8行，每行长度为64字节（相对于ELF文件膨胀了64倍）。
第0行（地址0x0）存储A指令开始的所有融合微码指令a0、b0、c0、d0;
第2行（地址0x80）存储B指令开始的所有融合微码指令b0、c0、d0;
第3行（地址0xC0）存储C指令开始的所有融合微码指令c0、d0;
第6行（地址0x180）存储D指令开始的所有融合微码指令d0。
其余的第1、4、5、7行都是空行，用于填充对齐。
能看出来，ELF 文件中代码地址和预翻译文件中代码地址是线性映射关系，只需要简单的地址映射就能找到对应的融合微码指令，地址关系如下：

\begin{equation}
Addr_{AOT} = Base +  Addr_{ELF} \times 64 
\end{equation}

再回顾一下，为何需要\textbf{重复存储}融合微码指令呢？这是因为可能有指令跳转到一行的中间位置（例如跳转到指令C），
这样就需要从预翻译文件中加载C指令开始的融合微码指令。
如果只存储A指令开始的融合微码指令，那么在跳转到C指令时，就需要重新翻译C指令开始的融合微码指令，这样会增加额外的开销，
这个开销包括调用动态二进制翻译器进行实时翻译、翻译缓存的填充等，需要数百拍才能完成，因此为了减少这个开销，需要重复存储融合微码指令。


\textbf{重复存储}办法本质上是一种用空间换时间的策略，通过增加预翻译文件的大小，减少了动态二进制翻译的开销，提高了性能。
虽然文件代码段膨胀了64倍，但目前主流的SPEC 2017程序的代码段大小在几十MB，这样的膨胀对于现代存储设备来说并不是很大的开销。
而对于内存来说，预翻译文件中有大量的空行，可以通过压缩算法进行透明压缩，减少内存占用，Linux中的zswap技术就是这样的一种技术。
对于多级缓存来说，只有被取到的缓存行才会被加载到缓存中，未被取到的缓存行不会被加载到缓存中，例如图\ref{img:aot_format}中可能只有第一行被取到，其他行不会被加载到缓存中。


\section{翻译缓存优化}

本文设计中，翻译缓存是和指令缓存同级的（或者说，是用于\textbf{替换}指令缓存的），用于存放融合微码指令。
如果翻译缓存大小和指令缓存大小相同，总行数相同，那么一行中存放的指令数量越多，缓存的总指令数量就越多，
缓存缺失率就会越低，性能就会越好，
因此翻译缓存的存储效率对性能影响较大，
存储效率的定义如公式\ref{eq:store_efficiency}所示。

% 存储效率公式
\begin{equation} \label{eq:store_efficiency}
  \text{存储效率} = \frac{\text{实际存放的指令数量}}{\text{缓存行能存储的最大指令数量}}
\end{equation}


如前文\ref{sec:tcache}所述，翻译缓存的每行组织形式和微码缓存类似，都是前面部分存放微码指令，后面存放立即数，微码指令和立即数相向生长，中间可能有\textbf{空洞}。
此外对于64字节长度的翻译缓存行，本文还设计了一个16字节长的元信息部分，用于存储一些额外的信息，如指令类型、指令长度等。
以定长的4字节指令举例，一行指令缓存可以存放16条指令，而一行翻译缓存最多存放12条指令，存储效率只有75\%。
更严峻的是，由于有3个结束条件的限制，实际存放的指令数量可能更少，存储效率更低，根据实验，
平均一行翻译缓存只能存放5条指令，存储效率只有31.25\%。

首先回顾下空洞产生的原因，是由于三个结束条件的限制，导致翻译缓存行中的微码指令提前结束，不能填满整个缓存行。
相对于\ref{sec:complex_isa}小节中提到的微码缓存的3个结束条件，
翻译缓存结束条件基本相同：1. 遇到指令缓存行的结尾；2. 遇到控制流指令；3. 翻译缓存行已满。


翻译缓存是从微码缓存设计演化而来的，因此翻译缓存的空洞问题也是从微码缓存继承而来的。
\cite{kotraImprovingUtilizationMicrooperation2020}
对传统微码缓存的空洞问题进行了分析，放松了前两个结束条件，能够提升微码缓存的存储效率，进而提升了12\%的整体性能。
本文也借鉴了这个思路，对RISC-V微译器中翻译缓存进行了优化，放松了前两个结束条件，提升了翻译缓存的存储效率。

\subsection{放松指令缓存行结尾}

前文中提到，遇到指令缓存行的结尾是一个结束条件，这样才能保证指令缓存行和翻译缓存行是一对多的关系。
当遇到自修改代码等情况时，需要刷新一行指令缓存行，这样才能方便找到对应的翻译缓存行进行刷新和替换。
然而，可以适当放松这个结束条件，允许连续的两行指令缓存行的指令填充到同一行翻译缓存行中。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=1\linewidth]{./image/aot_relaxed_icache.pdf}
    \bicaption{\enspace 放松指令缓存行结尾}{\enspace Relaxing the end of the instruction cache line}
    \fignote{允许连续的两行指令缓存行的指令填充到同一组翻译缓存行中，
    下一行的指令e0和指令f0可以填充到上一个指令缓存行对应的翻译缓存行中。}
    \label{img:aot_relaxed_icache}
  \end{figure}

如图\ref{img:aot_relaxed_icache}，展示了放松指令缓存行结尾的翻译缓存行组织形式。相对于\ref{img:aot_format}中的形式，
能允许下一行指令缓存行的指令填充到同一组翻译缓存行中，例如指令E和指令F可以填充到上一个指令缓存行对应的翻译缓存行中。
假如有指令跳转到C指令开始的基本块，就能直接取出c0-d0-e0-f0这四条微码指令（原本由于D指令为行结尾的结束条件，这一行只能存c0-d0指令），
这样就能减少这一行的空洞，提升了存储效率。

而对于自修改代码的处理，由于一行微码缓存行中的指令最多对应两行连续的指令缓存行，
例如c0-d0-e0-f0这四条微码指令对应的指令缓存行为A-B-C-D和E-F，所以只需要刷新对应的两行指令缓存行即可。
自修改代码的处理在实际场景中并不常见，并且对性能影响较小，因此放松这个结束条件是可行的。

\subsection{放松条件跳转指令}

前文中提到，控制流指令可能改变程序原本指令执行流，将顺序执行的指令分割为一个个基本块，因此控制流指令
是一个结束条件，这样能够保证翻译缓存行中的微码指令是一个基本块的连续指令。
控制流指令分为条件跳转和无条件跳转，
对于无条件跳转，一定会跳转到另一个基本块，作为结束条件是合理的；
但是对于条件跳转，在翻译过程中并不确定这条指令是否会跳转，如果不跳转，那么这条指令后面的指令也是连续的，
属于同一个基本块的，可以填充到同一行翻译缓存行中，因此可以适当放松条件跳转指令的结束条件。
（对于传统的微码缓存，预测为跳转的控制流指令才是一个结束条件，这是由于硬件译码可以快速判断是否跳转，但是对于RISC-V微译器，
软件预翻译过程的“译码”并不能判断是否跳转，因此需要放松这个结束条件。）

对于所有的条件跳转指令，都可以放松这个结束条件，将这些指令和后续指令都可以填充到同一行翻译缓存行中。
如图\ref{img:aot_relaxed_cond}，展示了放松条件跳转指令的翻译缓存行组织形式。对于条件跳转beq指令，可以将后续的指令也填充到同一行翻译缓存行中。
虽然在运行时，beq指令可能会跳转，后续的指令不会执行，但是对于不跳转的情况，后续的指令会执行，这样就能减少这一行的空洞，提升了存储效率。


\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{./image/aot_relaxed_cond.pdf}
    \bicaption{\enspace 放松条件跳转}{\enspace Relaxing the conditional jump}
    \fignote{翻译缓存行忽略了元信息和立即数。对于条件跳转beq指令，后续还能放微码；对于无条件跳转jr指令，后续不能放微码。}
    \label{img:aot_relaxed_cond}
  \end{figure}


\section{可变长翻译缓存行优化}

前文中提到过，每一个翻译缓存行中所有指令对应于一个基本块，根据本文插装分析的结果，每个基本块平均长度为5条指令。
然而，由于翻译缓存行的大小是固定的，为64字节，这意味着即便放松了结束条件，一行中有效的指令大约只有5条，占据20字节，存储效率平均只有35\%左右。

为此，本文提出了可变长翻译缓存行的优化方案，即根据基本块的长度动态调整翻译缓存行的大小，从而提升存储效率。
如图\ref{img:tcache_32}，展示了可变长翻译缓存行的组织形式，
本文实现了两种长度的翻译缓存行，分别为32字节和64字节，根据基本块的长度动态选择合适的翻译缓存行，对于长度小于等于6的基本块，选择32字节的翻译缓存行，
对于长度大于6的基本块，选择64字节的翻译缓存行。
同时在翻译缓存行的元信息中增加了一个字段，用于存储翻译缓存行的长度，这样就能在加载翻译缓存行时，根据这个字段动态选择合适的翻译缓存行并解析其中的指令。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.8\linewidth]{./image/tcache_32.pdf}
    \bicaption{\enspace 可变长翻译缓存行组织形式}{\enspace The organization form of the variable-length translation cache line}
    \fignote{有32字节和64字节两种长度，根据基本块的长度动态选择合适的翻译缓存行。}
    \label{img:tcache_32}
  \end{figure}

如果基本块平均长度为5条指令，均使用32字节的翻译缓存行，存储效率为$ 5*4 / 32 = 62.5\% $，
比固定长度的64字节翻译缓存行提升了接近一倍的存储效率，这样就能减少缓存缺失率，提升性能。

\section{融合指令集压缩编码优化}

前文中提到，借鉴RISC-V 压缩指令集的思想，融合微码指令集也可以进行压缩编码，从而在一行翻译缓存中存放更多的指令，提升存储效率。
回顾图\ref{img:TISA_encoder}，展示了融合微码可以有2字节和4字节两种长度，分别为压缩指令和标准指令。

由于x86微码和RISC-V微码共享压缩指令集，因此需要设计一套通用的压缩编码方案，能够同时满足x86和RISC-V的需求。
融合压缩指令的编码空间有限，总共可以支持31条2操作数、31条1操作数和32条0操作数的指令，
因此需要对指令集进行精心设计，找出最常用的指令，进行压缩编码。
本文通过QEMU插装工具分析了SPEC 2017中x86和RISC-V指令集的常用指令，发现这些指令占据了大部分的指令数，如表\ref{tab:spec_insts}所示。
根据x86和RISC-V指令集的常用指令，本文设计了一套融合指令集的压缩编码。


\begin{table}[]
  \centering
  \bicaption{\enspace x86和RISC-V在SPEC2017中前15个常用指令}{\enspace The top 15 most common instructions in SPEC2017 for x86 and RISC-V}
  \label{tab:spec_insts}
  \begin{tabular}{l|ll|ll}
    \hline
     & x86指令            & 比例     & RISC-V指令             & 比例     \\ \hline
  1  & mov\_R8\_M8      & 5.64\% & c.add\_R\_R         & 5.49\% \\
  2  & movsd\_R16\_M8   & 4.28\% & fld\_R\_M           & 4.64\% \\
  3  & mulsd\_R16\_R16  & 4.22\% & c.addi\_R\_IMM      & 4.53\% \\
  4  & addsd\_R16\_R16  & 3.66\% & fmul.d\_R\_R\_R     & 3.87\% \\
  5  & jne\_IMM8        & 3.17\% & add\_R\_R\_R        & 3.61\% \\
  6  & mov\_R8\_R8      & 3.04\% & c.ldsp\_R\_IMM\_R   & 3.27\% \\
  7  & je\_IMM8         & 2.97\% & c.mv\_R\_R          & 3.22\% \\
  8  & add\_R8\_IMM8    & 2.81\% & c.fld\_R\_IMM\_R    & 3.13\% \\
  9  & movapd\_R16\_R16 & 2.69\% & c.sdsp\_R\_IMM\_R   & 2.94\% \\
  10 & mov\_R4\_M4      & 2.59\% & fmadd.d\_R\_R\_R\_R & 2.80\% \\
  11 & movupd\_R16\_M16 & 2.17\% & fsub.d\_R\_R\_R     & 2.65\% \\
  12 & cmp\_R8\_R8      & 2.01\% & c.ld\_R\_IMM\_R     & 2.56\% \\
  13 & mov\_R4\_R4      & 1.91\% & ld\_R\_M            & 2.52\% \\
  14 & lea\_R8\_M8      & 1.83\% & bne\_R\_R\_IMM      & 2.25\% \\
  15 & subsd\_R16\_R16  & 1.67\% & fadd.d\_R\_R\_R     & 2.22\% \\ \hline
  \end{tabular}
  \end{table}



% 表\ref{tab:spec_insts}中列出了SPEC 2017中x86和RISC-V指令集的前15个常用指令，这些指令占据了大部分的指令数，因此需要优先考虑这些指令的压缩编码。


表\ref{app:compact_insts}中列出了本文设计的压缩指令集，
包括2操作数、1操作数和0操作数的指令，其中包括了常用的x86和RISC-V指令所对应的压缩融合微码
，如add、mov、cmp、syscall等。

\input{table/compact_insts.tex}