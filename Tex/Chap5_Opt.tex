\chapter{微译器优化方案}\label{chap:Opt}

前文中提到了微译器的引入能消除间接跳转的开销并缩小指令集语义差异，从而提升二进制翻译器的性能。
然而，微译器的引入也会带来一些新的问题，产生新的性能瓶颈，本节将针对这些问题提出一些优化方案。

如前文\ref{sec:tcache}所述，翻译缓存的每行组织形式和微码缓存类似，都是前面部分存放微码指令，后面存放立即数，微码指令和立即数相向生长，中间可能有\textbf{空洞}，产生额外开销。
此外对于64字节长度的翻译缓存行，我们还设计了一个16字节长的元信息部分，用于存储一些额外的信息，如指令类型、指令长度等。
因此相对于64字节长的指令缓存行，翻译缓存行的存储效率较低，会产生额外的存储开销。
以定长的4字节指令举例，一行指令缓存可以存放16条指令，而一行翻译缓存最多存放12条指令，存储效率只有75\%。
更严峻的是，由于有3个结束条件的限制，实际存放的指令数量可能更少，存储效率更低，根据我们的实验，
平均一行翻译缓存只能存放5条指令，存储效率只有31.25\%。

在我们的设计中，翻译缓存是和指令缓存同级的（或者说，是用于\textbf{替换}指令缓存的），用于存放融合微码指令，因此翻译缓存的存储效率对性能影响较大。
为了提升翻译缓存的存储效率，本文提出了一些优化方案，包括微码缓存优化、可变长微码行优化、融合指令集压缩编码优化等。
成果表明，这些优化方案能显著提升翻译缓存的存储效率，从而提升二进制翻译器的性能。

\section{翻译缓存优化}

我们首先回顾下空洞产生的原因，是由于前文中提出的三个结束条件的限制，导致翻译缓存行中的微码指令不能填满整个缓存行。
3个结束条件包括：1. 遇到指令缓存行的结尾；2. 遇到控制流指令；3. 翻译缓存行已满。


翻译缓存是从微码缓存设计演化而来的，因此翻译缓存的空洞问题也是从微码缓存继承而来的。
\cite{kotraImprovingUtilizationMicrooperation2020}
对传统微码缓存的空洞问题进行了分析，放松了前两个结束条件，能够提升微码缓存的存储效率，进而提升了12\%的整体性能。
我们也借鉴了这个思路，对翻译缓存进行了优化，放松了前两个结束条件，提升了翻译缓存的存储效率。

\subsection{放松指令缓存行结尾}

前文中提到，遇到指令缓存行的结尾是一个结束条件，这样才能保证指令缓存行和翻译缓存行是一对多的关系。
当遇到自修改代码等情况时，需要刷新一行指令缓存行，这样才能方便找到对应的翻译缓存行进行刷新和替换。
然而，我们可以适当放松这个结束条件，允许连续的两行指令缓存行的指令填充到同一行翻译缓存行中。

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=1\linewidth]{./image/aot_relaxed_icache.pdf}
    \caption{放松指令缓存行结尾的翻译缓存行组织形式，允许连续的两行指令缓存行的指令填充到同一组翻译缓存行中。}
    \label{img:aot_relaxed_icache}
  \end{figure}

如图\ref{img:aot_relaxed_icache}，展示了放松指令缓存行结尾的翻译缓存行组织形式。相对于\ref{img:aot_format}中的形式，
我们能允许下一行指令缓存行的指令填充到同一组翻译缓存行中，例如指令E和指令F可以填充到上一个指令缓存行对应的翻译缓存行中。
假如有指令跳转到C指令开始的基本块，我们就能直接取出c0-d0-e0-f0这四条微码指令（原本由于D指令为行结尾的结束条件，这一行只能存c0-d0指令），
这样就能减少这一行的空洞，提升了存储效率。

而对于自修改代码的处理，由于一行微码缓存行中的指令最多对应两行连续的指令缓存行，
例如c0-d0-e0-f0这四条微码指令对应的指令缓存行为A-B-C-D和E-F，所以只需要刷新对应的两行指令缓存行即可。
自修改代码的处理在实际场景中并不常见，并且对性能影响较小，因此放松这个结束条件是可行的。

\subsection{放松控制流指令}

前文中提到，控制流指令是一个结束条件，这样能够保证翻译缓存行中的微码指令是一个基本块的连续指令。
控制流指令分为条件跳转和无条件跳转，
对于无条件跳转，一定会跳转到另一个基本块，作为结束条件是合理的；
但是对于条件跳转，我们在翻译过程中并不确定这条指令是否会跳转，如果不跳转，那么这条指令后面的指令也是连续的，
属于同一个基本块的，可以填充到同一行翻译缓存行中，因此我们可以适当放松控制流指令的结束条件。
（对于传统的微码缓存，预测为跳转的控制流指令才是一个结束条件，这是由于硬件译码可以快速判断是否跳转，但是对于微译器，
软件预翻译过程的“译码”并不能判断是否跳转，因此需要放松这个结束条件。）

对于所有的条件跳转指令，我们都可以适当放松控制流指令的结束条件，将这些指令和后续指令都可以填充到同一行翻译缓存行中。
如图\ref{img:aot_relaxed_cond}，展示了放松控制流指令的翻译缓存行组织形式。对于条件跳转beq指令，我们可以将后续的指令也填充到同一行翻译缓存行中。
虽然在运行时，beq指令可能会跳转，后续的指令不会执行，但是对于不跳转的情况，后续的指令会执行，我们就能减少这一行的空洞，提升了存储效率。


\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.6\linewidth]{./image/aot_relaxed_cond.pdf}
    \caption{放松条件跳转的翻译缓存行（忽略了元信息和立即数），对于条件跳转beq指令，后续还能放微码；对于无条件跳转jr指令，后续不能放微码。}
    \label{img:aot_relaxed_cond}
  \end{figure}


\section{可变长翻译缓存行优化}

\section{融合指令集压缩编码优化}

